import requests, gzip, shutil

# UCSC direct link for chr1_GL383518v1_alt FASTA
url = "https://hgdownload.soe.ucsc.edu/goldenpath/hg38/chromosomes/chr1_GL383518v1_alt.fa.gz"

# Download the file
gz_file = "chr1_GL383518v1_alt.fa.gz"
fa_file = "chr1_GL383518v1_alt.fa"

resp = requests.get(url, stream=True)
resp.raise_for_status()
with open(gz_file, "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
        f.write(chunk)

# Decompress
with gzip.open(gz_file, "rb") as f_in, open(fa_file, "wb") as f_out:
    shutil.copyfileobj(f_in, f_out)

# ---- Read the FASTA sequence ----
def read_fasta(filename):
    seq = []
    with open(filename, "r") as f:
        for line in f:
            if not line.startswith(">"):  # skip header
                seq.append(line.strip())
    return "".join(seq)

seq = read_fasta(fa_file)

# -------------------------------
# PART 1: Print specific letters
# -------------------------------
print("\n--- Assignment Part 1 ---")
print("10th letter:", seq[9])     # index 9 = 10th base
print("758th letter:", seq[757]) # index 757 = 758th base

# -------------------------------
# PART 2: Reverse complement
# -------------------------------
def reverse_complement_keep_case(dna):
    """
    Creates the reverse complement of a DNA sequence.
    - Keeps original letter case (upper/lower)
    - Ignores 'n' or 'N'
    """
    complement = {
        "A":"T", "T":"A", "C":"G", "G":"C",
        "a":"t", "t":"a", "c":"g", "g":"c"
    }
    # Reverse the sequence and substitute with complement if valid
    rev_comp = [complement[base] for base in reversed(dna) if base in complement]
    return "".join(rev_comp)

# --- Apply to your sequence from Part 1 ---
rev_comp_seq = reverse_complement_keep_case(seq)

print("\n--- Assignment Part 2 ---")

# --- Print the 79th letter (1-based) ---
letter_79 = rev_comp_seq[78]  # 0-based index
print("79th letter of reverse complement (keeping case):", letter_79)

# --- Print letters 500 through 800 (inclusive) ---
letters_500_800 = rev_comp_seq[499:800]  # 0-based indexing
print("500thâ€“800th letters of reverse complement (keeping case):")
print(letters_500_800)

# -------------------------------
# PART 3: Nested dictionary (counts per kilobase)
# -------------------------------
def count_per_kb(sequence):
    # Create an empty dictionary to store results
    my_dict = {}

    # Go through the sequence in steps of 1000 bases
    for start in range(0, len(sequence), 1000):
        # Take 1000 bases (or fewer if at the end)
        chunk = sequence[start:start+1000]

        # Convert to uppercase so lower/upper letters are counted equally
        chunk_upper = chunk.upper()

        # Count each base
        A = chunk_upper.count("A")
        C = chunk_upper.count("C")
        G = chunk_upper.count("G")
        T = chunk_upper.count("T")

        # Save counts in the dictionary
        my_dict[start] = {"A": A, "C": C, "G": G, "T": T}

    return my_dict

# Use the function
my_dict = count_per_kb(seq)

print("\n--- Assignment Part 3 ---")
print("Counts in kilobase starting at 5000:", my_dict[5000])

# -------------------------------
# PART 4: Convert dictionary into lists & check sums
# -------------------------------
print("\n--- Assignment Part 4 ---")
first_kb_counts = my_dict[0]
first_kb_list = [
    first_kb_counts["A"],
    first_kb_counts["C"],
    first_kb_counts["G"],
    first_kb_counts["T"]
]
print("4a. First 1000 bases list:", first_kb_list)

# (b) Repeat for each kilobase
all_lists = []
for kb_start, counts in my_dict.items():
    kb_list = [
        counts["A"],
        counts["C"],
        counts["G"],
        counts["T"] ]
    all_lists.append(kb_list)
print(f"4b. Kilobase {kb_start}")

# (c) List containing each individual list
print("4c. All kilobase lists:", all_lists)

# (d) Sum of each list
print("4d. Sums of each kilobase list:")
for i, lst in enumerate(all_lists):
    print(f"   Kilobase {i}: {sum(lst)}")


# Comments for assignment answers:
# Expected sum = 1000 for each list,
# because each kilobase chunk has 1000 bases.
# BUT:
# - The very last kilobase may have <1000 bases if the sequence length
#   is not an exact multiple of 1000.
# - If the sequence contains ambiguous bases (e.g., "N"),
#   they are not counted in A, C, G, or T.
# Therefore, some sums may be < 1000.
